# Diplomacy AI Agent Framework Plan

This document outlines the plan for developing the AI agent framework for the Diplomacy game project. The Diplomacy engine is assumed to exist already.

## 1. Goals

*   Create a framework to host multiple AI agents representing different powers in Diplomacy.
*   Enable agents to perceive the game state provided by the engine.
*   Allow agents to maintain private state, memory, and reasoning processes ("thinking").
*   Facilitate communication (both public and private/selective) between agents.
*   Enable agents to generate valid orders for the Diplomacy engine based on their strategies.
*   Support different types of agent strategies (e.g., rule-based, LLM-based, hybrid).

## 2. Components

### 2.1. Agent Core

*   **Base `Agent` Class/Interface:** Defines the standard structure and methods for all agents.
    *   **Properties:**
        *   `power_name`: (e.g., "France", "Germany")
        *   `current_game_state`: Agent's view of the public game state.
        *   `private_memory`: Internal storage for plans, negotiation history, beliefs about others, secrets.
        *   `strategy_module`: The component responsible for decision-making.
        *   `communication_inbox`: To receive messages from other agents.
    *   **Methods:**
        *   `perceive(game_state)`: Updates the agent's `current_game_state` based on input from the engine/framework.
        *   `think()`: Internal reasoning step. Updates `private_memory`, formulates plans, evaluates strategies based on `current_game_state` and `communication_inbox`.
        *   `decide_orders()`: Generates the list of orders for the current turn based on the thinking process. Returns orders in a format the engine understands.
        *   `generate_messages()`: Decides which messages to send to which agents based on the thinking process.
        *   `receive_message(sender, message)`: Handles incoming messages, updating `private_memory` or `communication_inbox`.

### 2.2. Agent Framework / Orchestrator

*   **Purpose:** Manages the overall flow of the game from the agents' perspective.
*   **Responsibilities:**
    *   Instantiate and manage agent objects.
    *   Receive game state updates from the Diplomacy Engine.
    *   Distribute game state updates to agents (`agent.perceive()`).
    *   Trigger agent thinking (`agent.think()`).
    *   Manage inter-agent communication:
        *   Collect outgoing messages (`agent.generate_messages()`).
        *   Route messages to appropriate recipients (`agent.receive_message()`). Handle broadcast vs. private messages.
    *   Collect orders from agents (`agent.decide_orders()`).
    *   Submit consolidated orders to the Diplomacy Engine.
    *   Manage turn progression and phases (negotiation phase, order submission phase).

### 2.3. Communication Protocol

*   **Message Structure:** Define a clear format for messages (e.g., using Python dataclasses or dictionaries).
    *   `sender`: `power_name`
    *   `recipient`: `power_name` or `BROADCAST`
    *   `message_type`: (e.g., `PROPOSAL`, `ACCEPTANCE`, `REJECTION`, `INFORMATION`, `THREAT`, `QUERY`, `RESPONSE`)
    *   `content`: The actual message payload (can be structured text, proposed orders, etc.).
    *   `turn`: Game turn/year associated with the message.
*   **Transport Mechanism:** Likely direct Python method calls orchestrated by the Agent Framework (`framework` calls `recipient_agent.receive_message(...)`).

### 2.4. Strategy Module (Per Agent)

*   **Interface:** Define a standard interface for strategy modules so different strategies can be plugged into agents.
    *   `plan_turn(game_state, memory, messages)`: Takes current state, agent memory, and recent messages as input.
    *   `generate_orders()`: Returns the calculated orders.
    *   `generate_communications()`: Returns messages to send.
*   **Implementation:** Can range from simple rule-based logic to complex planning algorithms or integration with Large Language Models (LLMs) for negotiation and strategic reasoning.

### 2.5. Engine Adapter

*   **Purpose:** Translates data between the Agent Framework and the Diplomacy Engine.
*   **Responsibilities:**
    *   Convert engine's game state representation into the format expected by `agent.perceive()`.
    *   Convert orders generated by `agent.decide_orders()` into the format expected by the engine API.
    *   Handle API calls to the engine (e.g., `submit_orders`, `get_game_state`).

## 3. Development Phases

1.  **Foundation:**
    *   Define and implement the `Base Agent` interface and core properties.
    *   Implement the basic `Agent Framework` structure (agent management, turn cycling placeholder).
    *   Implement the `Engine Adapter` to fetch game state and submit dummy orders.
2.  **Basic Interaction:**
    *   Implement `agent.perceive()` and `agent.decide_orders()` (e.g., hold orders).
    *   Connect framework to engine: Fetch state -> `perceive` -> `decide_orders` -> submit orders. Run a simple turn.
3.  **Communication:**
    *   Define the `Communication Protocol` (message structure).
    *   Implement message handling in the `Agent Framework` (routing).
    *   Implement `agent.generate_messages()` and `agent.receive_message()` (basic logging).
4.  **Simple Strategy:**
    *   Implement a basic `Strategy Module` (e.g., support neighbours, attack weakest).
    *   Integrate it with the `Agent`'s `think()` method.
    *   Refine `agent.decide_orders()` based on strategy output.
5.  **Advanced Strategy & Negotiation:**
    *   Develop more sophisticated `Strategy Modules` (planning, opponent modeling).
    *   Integrate LLMs for natural language negotiation and complex reasoning within the `think()` and `generate_messages()` methods.
    *   Refine communication protocol for richer interactions (proposals, deals).
6.  **Testing & Refinement:**
    *   Develop test cases (unit tests for components, integration tests for framework-engine interaction, end-to-end game simulations).
    *   Iteratively refine agent strategies and communication abilities based on test results and observed gameplay.

## 4. Key Considerations

*   **State Management:** How to efficiently represent and update game state and agent memory.
*   **Concurrency/Timing:** How to handle agent thinking time, especially if using external APIs like LLMs. Synchronous vs. asynchronous operations.
*   **Scalability:** Design for potential future extensions (more agents, different games).
*   **Modularity:** Keep components loosely coupled for easier development and testing.
*   **LLM Integration (If applicable):** Prompt engineering, managing API costs/latency, grounding LLM reasoning in game rules and state.
*   **Security/Integrity:** Ensure agents cannot cheat (e.g., access other agents' private memory directly, submit invalid orders outside the framework). The framework acts as the referee between agents.
